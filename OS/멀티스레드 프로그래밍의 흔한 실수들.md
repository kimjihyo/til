
싱글스레드 프로그래밍에서 신경 쓸 필요가 없는 것들을 계속해서 신경을 써야하므로 멀티스레드 프로그래밍은 어렵다. 오늘은 책, “게임 서버 프로그래밍 교과서”에서 소개하는 멀티스레드 프로그래밍시 자주 하는 실수 패턴들을 적어보고자 한다.


## 읽기와 쓰기 모두에 잠금하지 않기

> 메모리에 값을 쓰고 있는데 다른 스레드가 그것을 읽으면 망가질 수 있다는 것은 인지하지만, 그냥 값을 읽고만 있으면 잠금을 하지 않더라도 안전하다는 막연한 생각 때문에 발생한다.

라고 책에 적혀있다. 물론 값이 변하지 않고 앞으로도 변할 일 없는 변수를 읽을때는 잠금할 필요는 없다. 하지만 변수의 값이 변하는 상황(다른 스레드에서 해당 변수에 대해서 쓰기 작업이 일어나는 상황)에서는 읽을 때에도 잠금이 필요하다.


## 잠금 순서 꼬임


뮤텍스 M1, M2, M3 그리고 스레드 T1, T2가 있다고 가정해보자. 스레드 T1에서 뮤텍스들을 M1→M2→M3 순서대로 잠금을 한다. 스레드 T2에서도 그 잠금 순서를 지켜주어야 한다 (e.g. M1→M2→M3, M1→M3, M2→M3 etc.). 그렇지 않고 스레드 T2에서 잠금 순서를 지켜주지 않으면 (e.g. M3 → M1 etc.) dead lock이 발생하게 된다. 


프로그램 규모가 커지면 이 규칙을 준수하기가 생각보다 어렵다. 제일 좋은 것은 잠금 순서 규칙을 최대한 적게 유지하는 것이다.


## 너무 좁은 잠금 범위

> 잠금 객체 범위가 너무 넓으면 컨텍스트 스위치가 발생할 때 운영체제가 해야 할 일이 매우 많아 집니다. 그리고 처리 병렬성이 떨어지기 때문에 멀티스레드 프로그래밍의 이유가 퇴색되기도 합니다.  
>   
> 잠금 범위를 좁히면 컨텍스트 스위치의 확률이 떨어지기는 합니다. 그러나 임계 영역 잠금이 컨텍스트 스위치보다는 훨씬 적더라도 단순한 산술 연산보다는 더 많은 처리 시간을 차지합니다. 따라서 임계 영역을 적당한 수준에서 나누면 좋습니다.

잠금 객체 범위와 컨텍스트 스위치의 상관관계가 어떻게 있는지는 잘 모르겠다. 관련 근거를 인터넷에서 찾아보고 싶었지만 검색실력의 부족으로 실패하였다. 


너무 좁은 잠금 범위는 critical section 개수의 증가로 이어진다. 그러면 잠금 순서를 지키기 어려워 프로그램을 유지 보수하기도 어렵고 개발자가 그만큼 실수할 확률도 높아진다.


## 디바이스 타임이 섞인 잠금


이 책에서는 신기하게 디바이스 타임(device time)이라는 용어를 사용한다. 처음 들어보았고 나는 I/O wait time 로 배웠고 이 말이 나는 좀 더 이해가 쉬운 것 같다. 두 용어는 같은 것을 의미한다. 즉, 디스크나 네트워크을 통해서 데이터를 읽기나 쓰기 작업을 할때 CPU가 기다리는 시간을 의미한다. 


이 기다리는 시간동안에는 스레드가 block 되고 CPU는 아무런 연산을 하지 않아 시간이 낭비된다. 따라서 이때는 다른 스레드를 위한 CPU 연산을 하는것이 효울적이다. 

> 우리는 알게모르게 디바이스 타임이 섞인 잠금을 하는 실수를 하고는 합니다. 그중 특히 자주 하는 실수는 로그 출력이나 콘솔 출력입니다.

## 잔금의 전염성으로 발생한 실수


생각해보면 당연하겠지만 잠금으로 보호되는 변수에서 얻어 온 값이나 포인터 주소 값 등이 로컬 변수로 있는 경우 예들 들어 아래 코드를 확인해보자.


```c++
void task() {
	m.lock();
	A* a = list.GetFirst();
	m.unlock();
	a->x++; // <- 문제가 되는 부분
}
```


로컬 변수가 뮤텍스로 보호받아야 하는 무언가를 가리키고 있고 이를 업데이트 하려고 해서 문제인것이다. 이런 상황에서는 잠금 상태를 유지해야한다.


## 잠금된 뮤텍스나 임계 영역 삭제


```c++
class A {
	mutex m;
	int a;
};

void func() {
	A* a = new A();
	a->m.lock();
	delete a;
}
```


책에서 가지고온 예시 코드이다. A 객체에 속한 뮤텍스를 잠그고 잠금 해제하지 않고 그냥 A를 delete 해버리는 경우이다.  A 클래스의 destructor에 뮤텍스 m이 이미 잠금하고 있으면 에러를 던지게 함으로서 위와 같은 상황은 해결할 수 있다.


## 일관성 규칙 깨기


로직이 맞물려 있는 둘 이상의 변수가 있을 때, 둘은 같이 잠금해야하는데 따로 잠금하는 경우를 말한다. 책의 링크드 리스트 예시를 살펴보자.


```c++
class node {
	Node *next;
};

node *list = nullptr;
int count = 0;

mutex list_mutex;
mutex count_mutex;

void func() {
	list_mutex.lock();
	node *new_node = new node();
	new_node->next = list;
	list = new_node;
	list_mutex.unlock();
	
	count_mutex.lock();
	count++;
	count_mutex.unlock();
}
```


list 와 count는 맞물려 돌아가는 변수들이다. list에 값이 추가되면 동시에 count도 증가해야한다. 하지만 두 변수를 개별적으로 잠금하고 있기때문에 한 변수가 수정되고 있는 동안 다른 스레드가 다른 변수를 읽거나 수정할 수 있는 상황이 벌어진다. 이때 해결 방법은 list와 count를 한 뮤텍스나 critical section으로 보호해야 하는 것이다.

