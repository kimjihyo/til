- 정렬과 관련된 기본적인 개념과 용어들을 이해할 수 있다.
- 기초적인 성능의 내부 정렬 알고리즘으로서, 선택 정렬, 버블 정렬, 삽입 정렬 및 셸 정렬의 원리와 수행 과정을 이해할 수 있다.
- 기초적인 정렬 알고리즘의 성능을 분석하고 장단점을 이해할 수 있다.

내부 정렬

- 전체 데이터를 주기억장치에  저장한 후 정렬을 수행하는 방식
- 비교 기반 알고리즘
	- 선택 정렬
	- 버블 정렬
	- 삽입 정렬
	- 셀 정렬
	- 퀵 정렬
	- 합병 정렬
	- 힙 정렬
- 데이터 분포 기반 알고리즘 (O(n))
	- 계수 정렬
	- 기수 정렬
	- 버킷 정렬

외부 정렬

- 모든 데이터를 보조기억장치에 저장한 후 정렬

안정적 정렬

- 동일한 값을 갖는 데이터가 여러 개 있을 때 정렬 전의 상대적 위치가 정렬 후 에도 그대로 유지되는 정렬

제자리 정렬

- 입력 배열 이외에 별도로 필요한 저장 공간이 상수 개를 넘지 않는 정렬

선택 정렬

- 가장 작은 값 부터 순서대로 선택해서 나열하는 방식
- 입력 데이터의 순서에 민감하지 않음
- 제자리 정렬 알고리즘
- 안정적이지 않은 정렬 알고리즘

```c++
void selectionSort(vector<int> &arr) {
    int n = arr.size();

    for (int i = 0; i < n - 1; ++i) {

        // Assume the current position holds
        // the minimum element
        int min_idx = i;

        // Iterate through the unsorted portion
        // to find the actual minimum
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[min_idx]) {

                // Update min_idx if a smaller
                // element is found
                min_idx = j; 
            }
        }

        // Move minimum element to its
        // correct position
        swap(arr[i], arr[min_idx]);
    }
}
```


버블 정렬

- 모든 인접한 두 데이터를 차례대로 비교해서 왼쪽 데이터가 더 큰 경우에는 오른쪽 데이터와 자리를 바꾸는 과정을 반복해서 정렬을 수행하는 방식
- 매 단계마다 가장 큰 데이터가 가장 오른쪽으로 위치하게 됨 (왼쪽에서 오른쪽으로 진행시)
- 안정적인 정렬 알고리즘
- 제자리 정렬 알고리즘
- 버블 정렬 개선
	- 인접한 두 데이터의 비교 횟수와 처리 단계의 수를 줄이도록 개선 가능
	- 빅오 관점에서 성능은 똑같지만 입력 데이터의 상태에 따라 성능이 달라짐
	- 입력 데이터의 원래 순서에 민감
		- 정렬된 순서로 주어진 경우 O(n)
		- 역순으로 정렬된 경우 O(n^2)

```c++
// An optimized version of Bubble Sort
void bubbleSort(vector<int>& v) {
 
    int n = v.size();

    for (int i = 0; i < n - 1; i++) {
        // Creating a flag to denote the case wwhen array
        // is sorted and doesnt cause any swap
        bool flag = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (v[j] > v[j + 1]) {
                swap(v[j], v[j + 1]);
                  // Setting flag true when swap happened
                flag = true;
            }
        }
      
          // Checking if the flag is set or not
        if (!flag)
            break;
    }
}
```


삽입 정렬

- 주어진 데이터를 하나씩 뽑은 후 이미 나열된 데이터가 항상 정렬된 상태를 유지하도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식
- 안정적인 정렬 알고리즘
- 제자리 정렬 알고리즘
- 입력 데이터의 원래 순서에 민감
	- 정렬된 순서로 주어진 경우 O(n)
	- 역순으로 정렬된 경우 O(n^2)

```c++
void insertionSort(int arr[], int n)
{
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;
        /* Move elements of arr[0..i-1], that are
           greater than key, to one position ahead
           of their current position */
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
```


셸 정렬

- 삽입 정렬의 단점 보완
	- 삽입 정렬의 단점: 현재 삽입하고자 하는 데이터가 삽입될 제 위치에서 많이 벗어나 있어도 한 번에 한 자리씩만 이동해서 찾아가야 함
- 멀리 떨어진 데이터와의 비교 교환으로 한번에 이동할 수 있는 거리를 늘려서 처리 속도 향상
- 부분배열의 크기/개수를 변화시키면서 삽입 정렬 수행
- 하나의 입력 배열을 물리적인 부분 배열로 나누지는 않음 (별도의 메모리 공간 할당 하지 않는다.)
- 사용하는 순열에 따라 성능이 달라짐(가장 좋은 간격을 찾는 것은 아직 미해결 과제)
	- 최선 : 로그, 최악 스퀘어드
- 제자리 정렬 알고리즘
- 안정적이지 않은 정렬 알고리즘
