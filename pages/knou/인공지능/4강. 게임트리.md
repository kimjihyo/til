
학습목표

1. 최대최소 탐색을 통해 게임의 수를 결정하는 방법을 설명할 수 있다.
2. 게임트리에서 불필요한 기지의 탐색을 줄여 효율성을 노이는 방법을 설명할 수 있다.
3. 몬테카를로 트리 탐색의 개념을 설명할 수 있다.
4. 몬테카를로 트리 탐색 알고리즘의 선택, 확장, 시뮬레이션, 역전파 단계를 설명할 수 있다.

주요용어

- 최대최소 탐색: 교대로 수를 두는 2인 게임에서 나의 수와 상대의 응수를 나타내는 게임트리에서 수를 결정하기 위한 탐색 기법
- a-b 가지치기: 최대최소 탐색트리의 불필요한 가지를 잘라냄으로써 탐색의 성능을 톺이기 위한 알고리즘
- 몬테카를로 트리 탐색: 게임과 같은 의사결정 문제의 해결을 위해 무작위 표본화를 바탕으로 구성되는 탐색 트리로부터 최적의 선택을 하기 위한 경험적 탐색 알고리즘
- 탐사(exploration): 평가의 불확실성으로 인해 아직은 덜 유망한 것으로 보이지만 향후 우수한 것으로 드러날 수 있는 수들을 선택할 수 있도록 하는 것
- 활용(exploitation): 지금까지의 결과 중 가장 우수한 결과를 낼 수 있는 수를 선택하는 것

최대최소 탐색(minimax search)의 개념

- 상대방과의 대결에서 승리하기 위한 게임
- 최대화: 내 차례에서는 내가 둘 수 있는 수 중에서 나에게 가장 유리한 수를 선택함
- 최소화: 상대방은 자신이 둘 수 있는 수 중에서 나에게 가장 불리한 수를 두려고 할 것이라고 가정함
- 트리의 규모가 매우 클 경우 모든 경우의 수를 탐색하여 종단상태까지 도달할 수 없음

a-b 가지치기

- 최대최소 탐색트리에서 탐색이 불필요한 가지를 잘라 내서 탐색의 성능을 높이기 위한 알고리즘
- a: 어떠한 최대화 노드의 최대화 과장에서 지금까지 구한 가장 큰 가치
	- 최소화 노드에서 어느 후계노드의 가치가 v일 때 a ≥ v라면 그 최소화 노드의 나머지 후계노드들은 가지치기함
- b: 어떠한 최소화 노드의 최소화 과정에서 지금까지 구한 가장 작은 가치
	- 최대화 노드에서 어느 후계노드의 가치가 v일 때 b ≤ v 라면 그 최대화 노드의 나머지 후계노드들은 가지치기함

몬테카를로 트리 탐색(MCTS)의 개요

- 게임과 같은 의사결정 문제에 활용되는 경험적 탐색 알고리즘
- 탐색공간의 무작위 표본화를 바탕으로 탐색트리를 구성함
- 어떠한 상태에 대한 가치를 추정할 때 경험적 지식을 반역한 평가함수를 사용하는 방식이 아니라 탐색공간을 무작위 방식으로 스스로 게임을 끝까지 진행해 보는 몬테카를로 롤아웃을 하는 시뮬레이션에 의해 노드의 가치를 추정한다.
- 따라서 어떠한 상태의 가치를 추정할 수 있는 경험적 평가함수가 필요하지 않다.

MCTS 탐사와 활용

- 탐사: 평가의 불확실성으로 인해 아직은 덜 유망한 것으로 보이지만 향후 우수한 것으로 드러날 수 있느 수들을 선택할 수 있도록 하는것
- 활용: 지금까지의 결과중 가장 우수한 결과를 이끌어 내는 수를 선택하는 것

MCTS 알고리즘을 구성하는 네 단계

	- 선택 → 확장 → 시뮬레이션 → 역전파
	- 선택
		- 루트노드에서 시작하여 선택전략에 따라 자식노드를 선택하는 과정을 싶이방향으로 반복
		- 아직 시도해 보지 않은 행동이 남아 있는 노드에 도달할 때까지 반복
	- 확장
		- 선택된 노드에 새로운 행동을 함으로써 자식노드를 생성하고 트리에 추가하여 트리를 확장
	- 시뮬레이션
		- 확장된 노드로부터 시작하여 게임이 끝날 때까지 스스로 게임을 진행 (랜덤하게 게임을 진행, 롤아웃, 플레이아웃)
	- 역전파
		- 시뮬레이션 결과를 확장된 노드로부터 루트노드까지 선택경로를 따라 역전파하여 통계를 업데이트함

```plain text
function MCTS(s) //s는 현재 상태
	nRoot <- CreateNode(s) // 루트노드 하나만 있는 트리로 시작
	nRoot.vSum <- 0, nRoot.NVisit <- 0 // 가치와 방문횟수 초기화
	while 시간 예산 이내 do
		n <- nRoot
		while not Terminal(n) do
			a <- NewAction(n) // 시도하지 않은 행동 선택
			if a = NULL then // 시도하지 않은 행동이 없다면
				n <- BestChild(n) // 선택 정책에 따라 자식노드 선택
			else
				n <- Expand(n, a) // 선택된 행동으로 자식노드 확장
				exit-loop
			end-if
		end-while
		value <- Rollout(n) // 시뮬레이션을 진행한 결과를 얻는다.
		Backpropagate(n, value) // 리프로부터 루트에 이르는 경로에 존재하는 노드의  정보 업데이트
	end-while
	return BestAction(nRoot)
	
	function Backpropagate(n, v)
		while n != NULL do
			n.vSum <- n.VSum + v
			n.NVisit <- n.NVisit + 1
			n <- n.parent
		end-while
```


MCTS의 선택 단계

	- upper confidence bond applited to trees (UCT) 알고리즘: 잘 알려진 선택전략 중 하나이다.
		- UCB1: 잘 알려진 신뢰도 상한
		- 노드 n에서 자식 노드들 중 하나를 선택할 때 자식노드의 UCB1의 계산
		- 강의 슬라이드 발췌: UCB1의 값이 큰 노드를 선택

			![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.33.34.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/be468a48-6628-44e2-8c56-229edd5978f7/af61b544-e80c-48b2-b04f-2cbeb564c702/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-03-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.33.34.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46625XZAU6Z%2F20250317%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250317T091507Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOn%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDMwFNh8xuXLVLBjIsQ0mhOXPGtu8380JuQ4SVKsupsfgIhAOvVIUdc3GxyztS15Uq1HpQCl%2BvTYArnLfuammlrjarEKv8DCEIQABoMNjM3NDIzMTgzODA1Igy3SW9IeIqz%2FCNVf8Aq3AOwcliwvu%2Bc6CJPx6Us9RNpIhYaypdtBkW0lrISyT59gzJFzgSodesE%2B0%2BspqiEQmV98wU9b8ukX1vaZGhaPH8DdBUdeU23UhV%2BNylc0%2FNudpOaScJvlwlhL0ui%2FlQH%2F0oH6HHcrOeLf9edGN5Fja1I2H4dQ%2FbnfCoWACTGno26ZisViSLh37QI7GSJSQl1zmbXkBMuDHMTDDlhti48PpNgMMFuKEIz2dixQ5yLw15qRMZcVnhJogkWyk22LV7y9NVXa5GqgazwGBVXtS1gOgXyWazuZXfGG3idf7Fj2jpl3BpROWqtXGcGKB1RUEJJUliqgzFmF7WYmHpVozReD77GtQ%2FecNdJmDSw%2F7NR9pbAskgmqkRHFDKXohD%2B4QHGKPejiV3%2BSLesK7RHt4jp48E5KIYvwrq4OM8%2FR%2FumQFHGw%2FFlzsdGUG11qOlfZ56ClI9VnIH6n6vovtlJbpFhaKiy9Ws51PzJ0pY%2Bl73L88Gag%2B1wmsD4%2FzCXMRMeGVimr203vXG%2Fn96UYIj6G4c5rHXbwFP9BuATa%2BbDe%2Fz7IWBydTLwirQiDs8W%2FyztsnZLrqpv2v0qwOYvpUqyDAx6DqeaCua%2FaGj9u%2BHPr8eOoH54%2BLtWEwBwG4mgc0PkHjDOzt%2B%2BBjqkASUMNi%2BP8W9jXu5wX2io4tSf0nPs2Tti2U3uh8iNrVuEhozdA3MMx324fNu4DZ5Tz%2FDJ%2B%2FWRos47w8bXZCrxDgZjX%2BtAKFX91PrHBWtRiA5GV%2F%2FfY2KeeAsh%2FO3qozPJrgPvH9bgEihpJFVDP%2FBP06OPwrTBByT7j1ikGCXOpHjkcG%2Fyjxug42DokFh90tc7JC4nB7IrY%2FuVlneC9gkbfZzgjcHS&X-Amz-Signature=17d7b53430809de108788b37baae189d7d3cbe2bbeb5971077abb75a073854ae&X-Amz-SignedHeaders=host&x-id=GetObject)


MCTS 시뮬레이션 단계

- 순수한 무작위 방법이나 적절한 전략에 따른 유사 무작위 방법으로 수를 선택하는 방법을 사용할 수 있다.

MCTS 최적 행동 선택

- 적절히 정한 계산 한계에 도달하여 시뮬레이션을 마치고 최종적으로 루트에서 자식노드들 중 하나를 선택하여 다음 수를 결정하는 전략
- 최종적인 최적 행동 선택을 위해서는 최대 자식, 강인한 자식, 최대-강인 자식, 안전한 자식 등 적절한 전략을 선택할 수 있다.
	- 최대 자식: 가장 큰 보상을 갖는 자식을 선택
	- 강인한 자식: 가장 많이 방문한 자식을 선택
	- 최대-강인 자식: 방문횟수가 가장 많고 가장 큰 보상을 갖는 루트 자식을 선택
	- 안전한 자식: 신뢰도 하한이 최대인 자식을 선택
